#pragma once

//练习BGL库的使用

//图的表示方法：
//1. 邻接表--》加权图			-- 存储空间小，访问某个边效率不高
//2. 邻接矩阵--》加权图			-- 存储空间大，访问某个边时效率高

//图又分为 有向图 和 无向图

//基础算法：
//（1）广度优先搜索， 同时生成了广度优先树，表示从顶点到某个节点的最短边数
//BFS（G， root）:  传入一个图，返回一个优先树
//前驱子图（predecessor subgraph）: 把广度优先树也表示成图的结构，每个顶点到达root经过的所有边（G‘ = （V', E'））;
//V’是从源顶点到所有可达点的集合（子集）， 只是一棵树
//得到的图，是一张连通图
//算法时间复杂度： O(V+E)

//（2）深度优先搜索
//DFS（G）
//前驱子图（predecessor subgraph）：（参考算法导论），是一个深度优先森林（很多树）， （G‘ = （V, E'））;
//V表示多个源顶点出发的集合，而不是只有一个点，BGL是否按照算法导论实现，则需要确认
//算法时间复杂度： O(V+E)
//深度优先所有可以用于边的分类，也可以用于判断一个有向图有没有回路（是否存在反向边）
//边的分类： 树边，反向边、正向边、交叉边（其他边）

//（3）拓扑排序
//举例：运用深度优先搜索，DAG（有向无回路图）进行拓扑排序： 将图的所有顶点，从左到有展开，使得所有的边都是从左指向右的，（如果存在回路，则不存在该排序）
//TOPOLICAL_SORT(G), 返回一个顶点顺序的链表

//（4）强连通分支
//概念： 针对有向图， 分支内的任意两个顶点，是互相可达的；
//可以使用深度优先搜索，把有向图分解为强连通分支
//STRONGLY-CONNECTED_COMPONENTS(G)  //粗糙的大概原理
//{
	//1. DFS:正向DFS， 获得优先森林，每个棵树此时可能包含数个连通分支还没有分开，但是树和树直接的就表示已经分开了
	//   在DFS操作过程中，计算每个顶点的完成时间，分支A-》分支B， 分支A的最晚完成时间一定比分支B来的晚
	//2. 计算的图G的转置，对这个反方向的的图再进行一次DFS操作
	//   for (每一个正向DFS获得优先树的)
	//{
	//	 以树中的最晚完成时间节点对应的装置图G‘中的对应点，为根节点，再进行一次DFS（G’），会构建一棵子树，这棵当前分分支外的节点排除掉（因为转置图已经把他们的连接通道方向）
	//   标记已经访问过的子树点（这些点构成了连通）
	//   找到分支A
	//   从下一个还没有访问过的最晚访问时间的顶点，继续下一个的连通分支的确定，找到了分支B
	//	 分支A一定指向分支B
	//}
//}

//（5）最小生成树问题（spnning tree）
//无向连通图，每一条边都有一个权值，确定一种顶点间的连接方法，使得总的权值最小，这种连接方法生成的其实是一棵树，而且是无回路的树
//通常的方法有两种：Kruskal算法 和 Prim算法，它们都使用贪心算法
//不做深究，理解问题，后面看看直接调用BGL接口

//（6）单源最短路径问题
//注意负权值回路问题， 不能有负权回路，原图不能有负权回路否则计算出来的最短路径不正确
//原图上是允许有正权回路得，但是得到得一条最短路径不可能存在正权回路
//最短路径一般是无环的
//最短如何表示，使用广度优先树的方式， BGL呢？
//最短路径不是唯一的
//Dijkstra算法 : 不能有负权边， 和 负权回路										O(V2)
//Bellmen-Ford算法： 可以有负全边， 但不能有负权回路， 允许检测是否存在负权回路     O(VE)
//有向无回路图最短路径算法：														O(V+E)
//不做深究，理解问题，后面看看直接调用BGL接口

//BGL相关：
//1. concept 和 model
//2. 模板元函数：每一个模板类都看成函数，模板参数 对应 函数参数，结果::type（需要自己用typedef定义） 对应 函数返回值
//3. trait
//4. BGL只需要传入对应数据的索引
//5. visitor类似回调

class BGLTesting
{
public:
	BGLTesting() { ; }


};

